#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <fstream>
#include <sstream>
#include <chrono>
using namespace std;

vector<int> dijkstra(vector<vector<pair<int,int>>>& adj, int src) {
    
    int V = adj.size();

    priority_queue<
        pair<int, int>,
        vector<pair<int, int>>,
        greater<pair<int, int>>
    > pq;

    vector<int> dist(V, INT_MAX);

    dist[src] = 0;
    pq.emplace(0, src);

    while(!pq.empty()) {
        auto top = pq.top();
        pq.pop();

        int d = top.first;
        int u = top.second;

        if(d > dist[u]) {
            continue;
        }

        for(auto &p : adj[u]) {
            int v = p.first;
            int w = p.second;

            if (dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                pq.emplace(dist[v], v);
            }
        }

    }

    return dist;
}

int main(int argc, char* argv[]) {

    /*
    checking the main args
    for (int i = 1; i < argc; i++) {
        cout << argv[i] << "\n";
    }
    */
    

    if(string(argv[1]) != "-d") {
        cerr << "Expected: '-d', but received: " << argv[1] << "\n ";
        return 1;
    }

    ifstream file(argv[2]);

    if(!file.is_open()) {
        cerr << "Could not load file: " << argv[2];
    }

    vector<vector<pair<int, int>>> adj;
    char c;
    string s;
    int e, v, min_w = INT_MAX, max_w= INT_MIN;

    bool cond = true;
    string line;
    int count = 0;
    while(getline(file, line)) {
        if(line[0] == 'c') {
            continue;
        }

        if(line[0] == 'p' && cond) {
            stringstream ss(line);
            ss >> c >> s >> v >> e;
            adj.resize(v + 1);
            cond = false;
        }
        
        if(line[0] == 'a' && !cond) {
            stringstream ss(line);
            int u, vv, w;
            ss >> c >> u >> vv >> w;
            if(w < min_w) {
                min_w = w;
            }
            if(w > max_w) {
                max_w = w;
            }
            adj[u].push_back({vv, w});
            --u; --vv;
            count++;
        }

        /*
        checking the file line

        cout << line << "\n"; 
        */
        

        if(count == e) {
            break;
        }
        
    }

    file.close();

    /*
    checking the adj list

    for (int i = 0; i < adj.size(); ++i) {
        for (auto& p : adj[i]) {
            cout << i << " " << p.first << " " << p.second << "\n";
        }
    }
    
    

    int src = 1;

    vector<int> result = dijkstra(adj, src);

    cout << "result \n";
    for (int i = 1; i < result.size(); i++) {
        cout << result[i] << " ";
    }
    cout << "\n";
    */

    if(string(argv[3]) != "-ss") {
        cerr << "Expected: '-ss', but received: " << argv[3] << "\n ";
        return 1;
    }

    ifstream ss_file(argv[4]);

    if(!ss_file.is_open()) {
        cerr << "Could not load file: " << argv[4];
    }

    vector<int> sources;

    while(getline(ss_file, line)) {
        if(line[0] == 's') {
            stringstream ss(line);
            char ch;
            int src;
            ss >> ch >> src;
            sources.push_back(src);
        }
    }

    /*for(int i : sources) {
        vector<int> result = dijkstra(adj, i);
        cout << "Source: " << i << "\n";
        for (int j = 1; j < result.size(); j++) {
            cout << result[j] << " ";
        }
        cout << "\n";
    }*/
    

    if(string(argv[5]) != "-oss") {
        cerr << "Expected: '-oss', but received: " << argv[5] << "\n ";
        return 1;
    }

    ofstream res_file(argv[6]);

    if(!res_file.is_open()) {
        cerr << "Could not open file to write: " << argv[5];
    }

    // adding some comments to output file
    res_file << "c This file contains the shortest path results\n";
    res_file << "c Generated by normal_dijkstra.cpp\n";
    res_file << "c -------------------------------------------\n";

    // adding problem line, file line and graph line to output file
    res_file << "p res sp ss karol" << "\n";
    res_file << "f " << argv[2] << " " << argv[4] << "\n";
    res_file << "g " << v << " " << e << " " << min_w << " " << max_w << "\n";
    res_file << "c -------------------------------------------\n";


    chrono::microseconds total_time(0);
    for(int i : sources) {
        auto start = chrono::high_resolution_clock::now();
        dijkstra(adj, i);
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
        total_time += duration;
    }
    
    chrono::duration<double, milli> average_time = total_time / sources.size();
    res_file << "t " << average_time.count() << "\n";
    
    res_file.close();

    return 0;
}