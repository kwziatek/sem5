#!/usr/bin/env python3
"""
generate_graph.py
Generate a graph file for testing Dijkstra in the following format:
- comment lines may start with `c`
- first non-comment line: `p sp <nodes> <edges>`
- following lines: `a u v w` (1-indexed nodes, weight w >= 0)

Usage example:
  python3 generate_graph.py --nodes 5000 --edges 50000 --outfile big_test.gr --seed 42 --max-weight 1000

The script by default allows repeated edges (faster and uses less memory). If you want unique edges, pass `--unique` (may use more memory/time for very large graphs).
"""

import argparse
import random
import sys


def main():
    p = argparse.ArgumentParser(description="Generate a graph file for Dijkstra testing")
    p.add_argument('--nodes', '-n', type=int, required=True, help='Number of nodes')
    p.add_argument('--edges', '-m', type=int, required=True, help='Number of directed edges')
    p.add_argument('--outfile', '-o', required=True, help='Output filename')
    p.add_argument('--seed', '-s', type=int, default=None, help='Random seed (optional)')
    p.add_argument('--max-weight', '-w', type=int, default=1000, help='Maximum edge weight (min is 1)')
    p.add_argument('--unique', action='store_true', help='Force unique edges (may be slow/large memory for huge graphs)')

    args = p.parse_args()

    n = args.nodes
    m = args.edges
    out = args.outfile
    seed = args.seed
    max_w = max(1, args.max_weight)
    unique = args.unique

    if n < 1:
        print('nodes must be >= 1', file=sys.stderr)
        sys.exit(1)
    if m < 0:
        print('edges must be >= 0', file=sys.stderr)
        sys.exit(1)

    max_possible = n * (n - 1)  # directed, no self-loop
    if unique and m > max_possible:
        print(f'Cannot generate {m} unique directed edges without self-loops for {n} nodes (max {max_possible}).', file=sys.stderr)
        sys.exit(1)

    rnd = random.Random(seed)

    with open(out, 'w') as f:
        f.write(f"c Graph generated by generate_graph.py\n")
        f.write(f"c nodes={n} edges={m} seed={seed} max_weight={max_w} unique={unique}\n")
        f.write(f"p sp {n} {m}\n")

        if unique:
            edges = set()
            # generate unique directed edges (u != v)
            while len(edges) < m:
                u = rnd.randint(1, n)
                v = rnd.randint(1, n)
                if u == v:
                    continue
                if (u, v) in edges:
                    continue
                w = rnd.randint(1, max_w)
                edges.add((u, v))
                f.write(f"a {u} {v} {w}\n")
        else:
            # allow duplicates; faster and constant memory
            for _ in range(m):
                u = rnd.randint(1, n)
                v = rnd.randint(1, n)
                while v == u:
                    v = rnd.randint(1, n)
                w = rnd.randint(1, max_w)
                f.write(f"a {u} {v} {w}\n")

    print(f'Wrote {out} (nodes={n}, edges={m}, seed={seed}, max_w={max_w}, unique={unique})')


if __name__ == '__main__':
    main()
